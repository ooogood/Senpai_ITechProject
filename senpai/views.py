from django.contrib.auth.models import User
from django.shortcuts import render
from django.http import HttpResponse, Http404, HttpResponseRedirect
from django.views.generic.base import View

from senpai import models
from senpai.forms import UserForm, UserProfileForm, ModuleForm
from senpai.models import UserProfile, Module, Note, Enrollment, Comment, Like
## import modelForms
from django.shortcuts import redirect
from django.urls import reverse
## import userForms
from django.contrib.auth import authenticate, login, logout
from django.utils.decorators import method_decorator
from django.contrib.auth.decorators import login_required
## helper
import os, mimetypes

from senpai.templatetags.senpai_template_tags import get_sorted_notes, get_home_modules, get_comments, get_mynote_notes, \
    get_mymodule_usermodules, get_mymodule_othermodules, get_all_module_list, is_user_admin, gen_admin_key
import urllib
from urllib import parse


# Create your views here.
# home page
class HomePage(View):
    @method_decorator(login_required(redirect_field_name=None))
    def get(self, request):
        # searching for module ajax request
        if request.is_ajax():
            # get search result from helper function
            context_dict = get_home_modules(request.user, request.GET['search'])
            return render(request, 'senpai/home_modules.html', context=context_dict)
        # get home page modules from helper function (including user modules and other modules) 
        context_dict = get_home_modules(request.user)
        # put extra info for admin button: is this an admin login
        context_dict['is_admin'] = is_user_admin(request.user)
        return render(request, 'senpai/home.html', context=context_dict)


# module page
class ModulePage(View):
    @method_decorator(login_required(redirect_field_name=None))
    def get(self, request, module_name_slug):
        context_dict = {}
        # try to get module by the slug in url
        try:
            module = Module.objects.get(slug=module_name_slug)
            context_dict['module'] = module
        # if the module doesn't exist, redirect to home
        except Module.DoesNotExist:
            return redirect(reverse('senpai:home'))
        # if it is ajax request, only return the note list content
        if request.is_ajax():
            # ajax: sort the note list and get the new note list from helper function
            if request.GET['action'] == 'sort':
                sort_type = request.GET['sort_type']
                result_dict = get_sorted_notes(module, sort_type)
                return render(request, 'senpai/notelist.html', context=result_dict)
            # ajax: like the module
            elif request.GET['action'] == 'like':
                e = Enrollment.objects.get_or_create(module=module, user=request.user)[0]
                e.save()
                # return empty response to clear the like button
                return HttpResponse('')
        # we put all_modules in the side bar
        context_dict['all_modules'] = Module.objects.all().order_by('name')
        # put extra info: did the user like the module
        # if not, show a like button in this module page
        if not Enrollment.objects.filter(user=request.user, module=module).exists():
            context_dict['haventLiked'] = True
        # context_dict['notes'] and context_dict['note_dict'] will be generated by calling get_sorted_notes in html
        return render(request, 'senpai/module.html', context=context_dict)


@login_required(redirect_field_name=None)
# module page: upload note action handler
def upload_note(request, module_name_slug):
    file = request.FILES.get('file', False)
    if file != False:
        module = Module.objects.get(slug=module_name_slug)
        new_note = Note.objects.create(module=module, user=request.user, file=file)
        new_note.save()
    return redirect(reverse('senpai:show_module',
                            kwargs={'module_name_slug': module_name_slug}))


# note page
class NotePage(View):
    @method_decorator(login_required(redirect_field_name=None))
    def get(self, request, note_id):
        context_dict = {}
        # try to get the note according to note_id in url
        try:
            note = Note.objects.get(id=note_id)
        # if the note doesn't exist, redirect to home
        except Note.DoesNotExist:
            return redirect(reverse('senpai:home'))
        # ajax: add comment on the note page
        if request.is_ajax():
            c = Comment.objects.create(note=note, user=request.user, content=request.GET['txt'])
            c.save()
            result_dict = get_comments(note, request.user)
            return render(request, 'senpai/commentlist.html', context=result_dict)
        # normal case: get content and like info of this note
        # note content
        context_dict['note'] = note
        context_dict['module'] = note.module
        # like info
        like = Like.objects.filter(note=context_dict['note'])
        context_dict['likes'] = like.count()
        context_dict['liked'] = like.filter(user=request.user).count()
        return render(request, 'senpai/note.html', context=context_dict)


@login_required(redirect_field_name=None)
# note page: like button clicked handler
def note_like_clicked(request, note_id):
    context_dict = {}
    # assert: We definitely can get the note because this function can only called in note page
    note = Note.objects.get(id=note_id)
    l = Like.objects.get_or_create(user=request.user, note=note)[0]
    liked = Like.objects.filter(note=note).filter(user=request.user).count()
    # use filter count to check if this user has liked this note
    if liked == 0:
        # action: like
        note.likes += 1
        note.save()
        l.save()
    else:
        # action: dislike
        note.likes -= 1
        note.save()
        l.delete()
    # render new like info to replace current page content
    like = Like.objects.filter(note=note)
    context_dict['likes'] = like.count()
    context_dict['liked'] = like.filter(user=request.user).count()
    return render(request, 'senpai/note_like_info.html', context=context_dict)


@login_required(redirect_field_name=None)
# note page: download note button clicked handler
def note_download(request, note_id):
    # assert: We definitely can get the note because this function can only called in note page
    note = Note.objects.get(id=note_id)
    if os.path.exists(note.file.path):
        with open(note.file.path, 'rb') as fh:
            # return the note content as download file response
            mime_type, _ = mimetypes.guess_type(note.file.path)
            response = HttpResponse(fh.read(), content_type=mime_type)
            response['Content-Disposition'] = 'attachment; filename=' + note.file.name
            return response
    raise Http404


# user function: my note (notes that I uploaded)
class Mynote(View):
    @method_decorator(login_required(redirect_field_name=None))
    def get(self, request):
        # ajax: delete a note that the user uploaded
        if request.is_ajax():
            need_del_note = request.GET.get('noteid')
            # if we can find the note, delete it
            if Note.objects.filter(id=need_del_note).exists():
                file = Note.objects.get(id=need_del_note).file
                file.delete()
                Note.objects.filter(id=need_del_note).delete()
            # return the new mynote list
            context_dict = get_mynote_notes(request.user)
            return render(request, 'senpai/mynote_notes.html', context=context_dict)
        # normal request
        # get all notes that this user uploaded, including their comment counts
        context_dict = get_mynote_notes(request.user)
        context_dict['user'] = request.user
        # put extra info about user function type: to show other user function buttons
        context_dict['uf_type'] = 'mynotes'
        return render(request, 'senpai/mynote.html', context=context_dict)


# user function: mylike (notes that I liked)
@login_required(redirect_field_name=None)
def mylike(request):
    context_dict = {}
    # put extra info about user function type: to show other user function buttons
    context_dict['uf_type'] = 'mylikes'
    # get a list of Like by the user
    like_list = Like.objects.filter(user=request.user)
    note = []
    # acquire Note objects from the Like objects
    for likes in like_list:
        note.append(likes.note)
    # count comments for each note
    comment = {}
    for n in like_list:
        comment[n.note.id] = Comment.objects.filter(note=n.note).count()
    context_dict['note'] = like_list
    context_dict['user'] = request.user
    context_dict['comments'] = comment
    return render(request, 'senpai/mylike.html', context=context_dict)


# user - mymodule
@login_required(redirect_field_name=None)
def mymodule(request):
    context_dict = {}
    # put extra info about user function type: to show other user function buttons
    context_dict['uf_type'] = 'mymodules'
    # ajax: enroll or unenroll a module
    # only do the add or delete enrollment in backend when refreshing user block
    # to avoid duplicate operations
    if request.is_ajax():
        # if thie request is to refresh modules that user has enrolled
        if request.GET.get('block') == 'user':
            action_type = request.GET.get('action_type')
            module_id = request.GET.get('module_id')
            this_module = Module.objects.get(id=module_id)
            if action_type == 'select':
                if not Enrollment.objects.filter(module=this_module, user=request.user).exists():
                    e = Enrollment.objects.get_or_create(module=this_module, user=request.user)[0]
                    e.save()
            elif action_type == 'delete':
                if Enrollment.objects.filter(module=this_module, user=request.user).exists():
                    Enrollment.objects.filter(module=this_module, user=request.user).delete()
            return render(request, 'senpai/mymodule_usermodules.html', context=get_mymodule_usermodules(request.user))
        # if thie request is to refresh modules that user hasn't enrolled
        else:
            return render(request, 'senpai/mymodule_othermodules.html', context=get_mymodule_othermodules(request.user))

    return render(request, 'senpai/mymodule.html', context=context_dict)


def testFunction(request):
    pass

# main entry of sign in/up page
def signinup(request):
    context_dict = {}
    context_dict['cust_errmsg'] = ''
    context_dict['form_errmsg'] = ''
    # if this is a sign in request
    if request.method == 'POST' and request.POST.get('signin_form') == 'submit':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(username=username, password=password)
        if user:
            if user.is_active:
                login(request, user)
                return redirect(reverse('senpai:home'))
            else:
                context_dict['cust_errmsg']="Your senpai account is disabled."
        else:
            context_dict['cust_errmsg']=(f"Invalid signin details: {username}, {password}")
    # if this is a sign up request
    elif request.method == 'POST' and request.POST.get('signup_form') == 'submit':
        user_form = UserForm(data=request.POST)
        profile_form = UserProfileForm(data=request.POST)

        if user_form.is_valid() and profile_form.is_valid():
            # render form into objects without saving
            user = user_form.save(commit=False)
            user.set_password(user.password)
            profile = profile_form.save(commit=False)

            # Get the user input key from form
            getKey = profile.admin_key
            # Access to judgement
            try:
                # if user input admin key
                if getKey:
                    admin = UserProfile.objects.get(admin_key=getKey)
                    # auto generate new admin key for old admin and new admin
                    gen_admin_key( admin )
                    admin.save()
                    gen_admin_key( profile )
                    is_admin = 1
                else:
                    # create a non-admin account
                    is_admin = 0
                profile.is_admin = is_admin
                user.save()
                profile.user = user
                profile.save()
                # login and redirect to home if sign up successful
                login(request, user)
                return redirect(reverse('senpai:home'))
            except UserProfile.DoesNotExist:
                # cannot find a adminkey like this.
                context_dict['cust_errmsg'] = "Invalid admin key supplied."
        else:
            for value in user_form.errors.values():
                # only shows the first error message for beauty
                context_dict['form_errmsg'] += value
                break
    # if there is no sign in or sign up request
    context_dict['user_form'] = UserForm()
    context_dict['profile_form'] = UserProfileForm()
    return render(request, 'senpai/signinup.html', context=context_dict)


@login_required(redirect_field_name=None)
def user_logout(request):
    logout(request)
    return redirect(reverse('senpai:home'))


@login_required(redirect_field_name=None)
def genAdminKey(request):
    user = request.user
    statusAdmin = UserProfile.objects.get(user=user).is_admin
    if statusAdmin == 0:
        return redirect(reverse('senpai:home'))
    """This function generate 10 character long hash"""

    status = UserProfile.objects.get(user=request.user)
    if request.is_ajax() and request.GET.get('req') == 'gen_admin_key':
        gen_admin_key( status )
        status.save()
        return HttpResponse(f"{status.admin_key}")
    context_dict = {'key': status.admin_key}
    return render(request, 'senpai/generateKey.html', context=context_dict)

@login_required(redirect_field_name=None)
def module_management(request):
    user = request.user
    status = UserProfile.objects.get(user=user).is_admin
    context_dict = {}
    if status == 0:
        return redirect(reverse('senpai:home'))

    if request.is_ajax():
        action_type = request.GET.get('action_type')
        if action_type == 'add':
            module_name = request.GET.get('module_name')
            m = Module.objects.get_or_create(name=module_name)[0]
            m.save()
        elif action_type == 'delete':
            module_id = request.GET.get('module_id')
            try:
                Module.objects.get(id=module_id).delete()
            except Module.DoesNotExist:
                # if no this module, do nothing
                pass
        return render(request, 'senpai/management_module_list.html', context=get_all_module_list())
    return render(request, 'senpai/management_module.html', context=context_dict)
