import hashlib

from django.contrib.auth.models import User
from django.shortcuts import render
from django.http import HttpResponse, Http404
from django.views.generic.base import View

from senpai.forms import UserForm, UserProfileForm
from senpai.models import UserProfile, Module, Note, Enrollment, Comment, Like
## import modelForms
from django.shortcuts import redirect
from django.urls import reverse
## import userForms
from django.contrib.auth import authenticate, login, logout
from django.utils.decorators import method_decorator
from django.contrib.auth.decorators import login_required
from datetime import datetime, time
## helper
import os, math, mimetypes

from senpai.templatetags.senpai_template_tags import get_sorted_notes, get_home_modules, get_comments


# Create your views here.
# home page
class HomePage(View):
    @method_decorator(login_required)
    def get(self, request):
        if request.is_ajax():
            context_dict = get_home_modules(request.user, request.GET['search'])
            return render(request, 'senpai/home_modules.html', context=context_dict)
        context_dict = get_home_modules(request.user)
        return render(request, 'senpai/home.html', context=context_dict)


# module page
class ModulePage(View):
    @method_decorator(login_required)
    def get(self, request, module_name_slug):
        context_dict = {}
        try:
            module = Module.objects.get(slug=module_name_slug)
            context_dict['module'] = module
        # context_dict['notes'] and context_dict['note_dict'] will be generated by calling get_sorted_notes in html
        except Module.DoesNotExist:
            context_dict['module'] = None
        # if it is ajax request, only return the note list
        if request.is_ajax():
            sort_type = request.GET['sort_type']
            result_dict = get_sorted_notes(module, sort_type)
            return render(request, 'senpai/notelist.html', context=result_dict)

        context_dict['all_modules'] = Module.objects.all()
        return render(request, 'senpai/module.html', context=context_dict)


# note page
class NotePage(View):
    @method_decorator(login_required)
    def get(self, request, note_id):
        context_dict = {}
        if request.is_ajax():
            note = Note.objects.get(id=note_id)
            change_page_num = int(request.GET.get('page_num', -1))
            if change_page_num == -1:
                # add a comment to this note
                c = Comment.objects.create(note=note, user=request.user, content=request.GET['txt'])
                c.save()
                result_dict = get_comments(note)
                return render(request, 'senpai/commentlist.html', context=result_dict)
            else:
                # change comment page
                result_dict = get_comments(note, change_page_num)
                return render(request, 'senpai/commentlist.html', context=result_dict)
        try:
            context_dict['note'] = Note.objects.get(id=note_id)
            context_dict['module'] = context_dict['note'].module
            like = Like.objects.filter(note=context_dict['note'])
            context_dict['likes'] = like.count()
            context_dict['liked'] = like.filter(user=request.user).count()
        except Note.DoesNotExist:
            context_dict['module'] = None
            context_dict['note'] = None
            context_dict['likes'] = None
            context_dict['liked'] = None
        return render(request, 'senpai/note.html', context=context_dict)


@login_required
def note_like_clicked(request, note_id):
    context_dict = {}
    note = Note.objects.get(id=note_id)
    liked = Like.objects.filter(note=note).filter(user=request.user).count()
    l = Like.objects.get_or_create(user=request.user, note=note)[0]
    if liked == 0:
        # like
        l.save()
    else:
        # dislike
        l.delete()
    like = Like.objects.filter(note=note)
    context_dict['likes'] = like.count()
    context_dict['liked'] = like.filter(user=request.user).count()
    return render(request, 'senpai/note_like_info.html', context=context_dict)


@login_required
def note_download(request, note_id):
    note = Note.objects.get(id=note_id)
    print(note.file.path)
    if os.path.exists(note.file.path):
        with open(note.file.path, 'rb') as fh:
            mime_type, _ = mimetypes.guess_type(note.file.path)
            response = HttpResponse(fh.read(), content_type=mime_type)
            response['Content-Disposition'] = 'attachment; filename=' + note.file.name
            return response
    raise Http404


# user - my note
@login_required
def mynote(request, mynote_page_id=1):
    context_dict = {}
    if request.user.is_authenticated:
        # get note_list
        note_list = Note.objects.filter(user=request.user).order_by('date')[mynote_page_id * 8 - 8:mynote_page_id * 8]
        comment = {}
        for n in note_list:
            comment[n.id] = Comment.objects.filter(note=n).count()

        note_num = Note.objects.filter(user=request.user).count()
        page_maximum = math.ceil(note_num / 8)
        context_dict['note'] = note_list
        context_dict['user'] = request.user
        context_dict['page'] = range(1, page_maximum + 1)
        context_dict['page_now'] = mynote_page_id
        context_dict['page_last'] = mynote_page_id - 1
        context_dict['page_next'] = mynote_page_id + 1
        context_dict['comments'] = comment
    else:
        return render(request, 'senpai/login_error.html')
    response = render(request, 'senpai/mynote.html', context=context_dict)
    return response


# user - mylike
@login_required
def note_like(request):
    user = request.user
    note_id = request.GET.get('note_id')
    note = Note.objects.filter(id=note_id)
    likenote = Like.objects.filter(user=user, note=note).count()

    if likenote:
        Like.objects.filter(user=user, note=note).delete
    else:
        Like.objects.get_or_create(user=user, note=note)
    response = render(request, 'senpai/note_like.html')
    return response


@login_required
def mylike(request, mylike_page_id=1):
    context_dict = {}
    if request.user.is_authenticated:
        # get note_list
        like_list = Like.objects.filter(user=request.user)[mylike_page_id * 8 - 8:mylike_page_id * 8]
        note = []
        for likes in like_list:
            note.append(likes.note)

        like_num = Like.objects.filter(user=request.user).count()
        page_maximum = math.ceil(like_num / 8)
        context_dict['note'] = like_list
        context_dict['user'] = request.user
        context_dict['page'] = range(1, page_maximum + 1)
        context_dict['page_now'] = mylike_page_id
        context_dict['page_last'] = mylike_page_id - 1
        context_dict['page_next'] = mylike_page_id + 1
    else:
        return render(request, 'senpai/login_error.html')
    response = render(request, 'senpai/mylike.html', context=context_dict)
    return response


@login_required
def mymodule(request):
    context_dict = {}
    if request.user.is_authenticated:
        my_module = []
        other_module = []
        # get module_list
        my_enrollment = Enrollment.objects.filter(user=request.user)
        for e in my_enrollment:
            my_module.append(e.module)

        all_modules = Module.objects.all()
        for m in all_modules:
            if not m in my_module:
                other_module.append(m)

        context_dict['user_modules'] = my_module
        context_dict['other_modules'] = other_module
    response = render(request, 'senpai/mymodule.html', context=context_dict)
    return response


def unenrollment(request, module_id):
    next = request.GET.get('next', '/senpai/mymodule/')

    this_module = Module.objects.get(id=module_id)
    if Enrollment.objects.filter(module=this_module, user=request.user).exists():
        Enrollment.objects.filter(module=this_module, user=request.user).delete()

    return redirect(next)


def enrollment(request, module_id):
    next = request.GET.get('next', '/senpai/mymodule/')

    this_module = Module.objects.get(id=module_id)
    if not Enrollment.objects.filter(module=this_module, user=request.user).exists():
        e = Enrollment.objects.get_or_create(module=this_module, user=request.user)[0]
        e.save()

    return redirect(next)


@login_required
def delete_note(request, note_id):
    next = request.GET.get('next', '/senpai/mynote/')

    if Note.objects.filter(id=note_id).exists():
        Note.objects.filter(id=note_id).delete()

    return redirect(next)

'''
def user_register(request):
    registered = False

    if request.method == 'POST':

        user_form = UserForm(data=request.POST)
        profile_form = UserProfileForm(data=request.POST)
        key = request.POST.get('adminKey', "")

        if user_form.is_valid() and profile_form.is_valid():

            if key != '0':
                keySet = UserProfile.objects.filter(admin_key=key)
                if keySet:
                    UserProfile.is_admin = '1'
                else:
                    print("Admin Key error or non-existent, please re-input")

            user = user_form.save()

            user.set_password(user.password)
            user.save()
            print("test1\n")
            profile = profile_form.save(commit=False)
            print("test2\n")
            profile.user = user
            print("test3\n")
            profile.save()
            print("test4\n")
            registered = True
        else:
            print(user_form.errors, profile_form.errors)
    else:
        user_form = UserForm()
        profile_form = UserProfileForm()

        return render(request,
                      'senpai/register.html',
                      {'user_form': user_form, 'profile_form': profile_form, 'registered': registered})
'''


def register(request):
    registered = False
    if request.method == 'POST':
        user_form = UserForm(data=request.POST)
        profile_form = UserProfileForm(data=request.POST)
        key = request.POST.get('adminKey', "")
        if user_form.is_valid() and profile_form.is_valid():

            if key != 0:
                keySet = UserProfile.objects.filter(admin_key=key)
                if keySet:
                    UserProfile.is_admin = 1
                else:
                    print("Admin Key error or non-existent, please re-input")

            user = user_form.save()
            user.set_password(user.password)
            user.save()
            profile = profile_form.save(commit=False)
            profile.user = user
            profile.save()
            registered = True
        else:
            print(user_form.errors, profile_form.errors)
    else:
        user_form = UserForm()
        profile_form = UserProfileForm()

    return render(request,
                  'senpai/combineLogReg.html',
                  {'user_form': user_form, 'profile_form': profile_form, 'registered': registered})


# login
def user_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(username=username, password=password)
        if user:
            if user.is_active:
                login(request, user)
                return redirect(reverse('senpai:home'))
            else:
                return HttpResponse("Your senpai account is disabled.")
        else:
            print(f"Invalid login details: {username}, {password}")
            return HttpResponse("Invalid login details supplied.")
    else:
        return render(request, 'senpai/combineLogReg.html')


@login_required
def restricted(request):
    return render(request, 'senpai/restricted.html')


@login_required
def user_logout(request):
    logout(request)
    return redirect(reverse('senpai:home'))

'''
def generateAdminKey(request, UserProfile):
    """This function generate 10 character long hash"""
    hashCode = hashlib.sha1()
    hashCode.update(str(time.time()))
    UserProfile.admin_key = hashCode.hexdigest()[:-10]
    # user.generate_statue = True  # 修改生成key的状态
    return hashCode.hexdigest()[:-10]
'''